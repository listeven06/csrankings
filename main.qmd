---
title: "Main"
format: html
editor: visual
---

## Load Datasets

```{r load_data}
library(readr)

csrankings <- read_csv("datasets/csrankings.csv")
author_info <- read_csv("datasets/generated-author-info.csv")
acm_fellows <- read_csv("datasets/acm-fellows.csv")
turing_awards <- read_csv("datasets/turing.csv")
geolocation <- read_csv("datasets/geolocation.csv")
country_info <- read_csv("datasets/country-info.csv")
dblp_aliases <- read_csv("datasets/dblp-aliases.csv")
conference_ranking <- read_csv("datasets/conference_ranking.csv")
us_news <- read_csv("datasets/data.csv")
field_conference <- read_csv("datasets/field_conference.csv")

head(csrankings)
head(author_info)
head(acm_fellows)
head(turing_awards)
head(geolocation)
head(country_info)
head(dblp_aliases)
head(conference_ranking)
head(us_news)
head(field_conference)
```

## Create and Load Databases

### csrankings

```{r split_name}
library(tidyr)
library(dplyr)

# Separate names while keeping the original intact
csrankings <- csrankings %>%
  mutate(researcher_name = name) %>%
  separate(
    col = name,
    into = c("first_name", "middle_name", "last_name"),
    sep = " ", 
    extra = "merge",  # Ensures last_name gets only the last word
    fill = "right"    # Fills missing middle name with NA
  )

head(csrankings)
```

```{r csrankings}
library(RSQLite)
library(DBI)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# csranking

drop_check <- "DROP TABLE IF EXISTS csrankings;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS csrankings (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    affiliation VARCHAR(255),
    homepage VARCHAR(2048),
    scholarid VARCHAR(16),
    PRIMARY KEY (researcher_name)
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM csrankings;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "csrankings", csrankings, append = TRUE, row.names = FALSE)
  message("Data loaded into csrankings table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(result)

RSQLite::dbDisconnect(connection)
```

### acm_fellows

```{r preprocess_acm_fellows1}
acm_fellows <- acm_fellows %>%
  mutate(researcher_name = name) %>%
  extract(
    col = name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^([^\\s]+)\\s+(?:(.*)\\s+)?([^\\s]+)$",
  )
head(acm_fellows)
```

```{r preprocess_acm_fellows2}
# just a preference
names(acm_fellows)[names(acm_fellows) == "year"] <- "award_year"

colnames(acm_fellows)
```

```{r acm_fellows}
library(RSQLite)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS acm_fellows;"

RSQLite::dbExecute(connection, drop_check)

# acm_fellows
query <- "
CREATE TABLE IF NOT EXISTS acm_fellows (
  researcher_name VARCHAR(255),
  first_name VARCHAR(255),
  middle_name VARCHAR(255),
  last_name VARCHAR(255),
  award_year INT,
  PRIMARY KEY (researcher_name, award_year),
  FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name)
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM acm_fellows;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "acm_fellows", acm_fellows, append = TRUE, row.names = FALSE)
  message("Data loaded into acm_fellows table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM acm_fellows;")
print(result)

RSQLite::dbDisconnect(connection)
```

### country_info

```{r country_info}
library(RSQLite)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS country_info;"

RSQLite::dbExecute(connection, drop_check)


# country_info
query <- "
CREATE TABLE IF NOT EXISTS country_info (
  institution VARCHAR(255),
  region VARCHAR(255),
  countryabbrv VARCHAR(16),
  PRIMARY KEY (institution),
  FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM country_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "country_info", country_info, append = TRUE, row.names = FALSE)
  message("Data loaded into country_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM country_info;")
print(result)

RSQLite::dbDisconnect(connection)
```

### conference_ranking

For the conference ranking (conference_ranking.csv) file, when you create a corresponding table, in addition to the three attributes for abbreviation, full name, rating, also include another attribute for “academic society” whose value can be ‘ACM’, ‘IEEE’, ‘ACM+IEEE’, or ‘other’. You will need to scrape this information from the conference full name. E.g., if a conference is titled “ACM conference on Machine Learning” since ACM appears in the title, we will the value ‘ACM’ for the “academic society”. Likewise, a conference such as “IEEE conference on Big Data” will be marked as an ‘IEEE’ conference. If neither IEEE nor ACM appear, then we will assign the value of ‘other’ to the field, while if both IEEE and ACM appear, we will assign the value ‘ACM+IEEE’.

```{r preprocess_conference_ranking}
colnames(conference_ranking)

names(conference_ranking)[names(conference_ranking) == "Antonym"] <- "acronym"
names(conference_ranking)[names(conference_ranking) == "Name"] <- "conference_name"
names(conference_ranking)[names(conference_ranking) == "Rank"] <- "rank"

colnames(conference_ranking)
head(conference_ranking)
```

```{r conference_ranking}
library(RSQLite)
library(DBI)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")


drop_check <- "DROP TABLE IF EXISTS conference_ranking;"

RSQLite::dbExecute(connection, drop_check)

# conference_ranking
query <- "
CREATE TABLE IF NOT EXISTS conference_ranking (
  acronym VARCHAR(16),
  conference_name VARCHAR(255),
  rank VARCHAR(2),
  academic_society VARCHAR(8),
  PRIMARY KEY (acronym, conference_name),
  FOREIGN KEY (acronym) REFERENCES generated_author_info(acronym)
);
"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM conference_rankings;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "conference_ranking", conference_ranking, append = TRUE, row.names = FALSE)
  message("Data loaded into conference_ranking table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM conference_ranking;")
print(result)

# Scrape academic_society column

query <- "
UPDATE conference_rankings
SET academic_society = CASE
    WHEN (conference_name LIKE '%ACM%' AND conference_name LIKE '%IEEE%') THEN 'ACM+IEEE'
    WHEN conference_name LIKE 'ACM%' THEN 'ACM'
    WHEN conference_name LIKE 'IEEE%' THEN 'IEEE'
    ELSE 'other'
END;
"

RSQLite::dbExecute(connection, query)

result <- dbGetQuery(connection, "SELECT * FROM conference_rankings;")
print(result)


RSQLite::dbDisconnect(connection)
```

### us_news

```{r preprocess_us_news}
colnames(us_news)

# Replace dots with underscores in column names
colnames(us_news) <- gsub("\\.", "_", colnames(us_news))

colnames(us_news)
```


```{r us_news}
library(RSQLite)
library(DBI)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS us_news;"

RSQLite::dbExecute(connection, drop_check)

# usnews / data
query <- "
CREATE TABLE IF NOT EXISTS us_news (
  institution_displayName VARCHAR(255),
  institution_schoolType VARCHAR(255),
  institution_aliasNames TEXT,
  institution_state VARCHAR(50),
  institution_city VARCHAR(255),
  institution_zip VARCHAR(10),
  institution_region VARCHAR(50),
  institution_isPublic BOOLEAN,
  institution_institutionalControl VARCHAR(255),
  institution_primaryPhotoCardThumb TEXT,

  ranking_displayRank VARCHAR(50),
  ranking_sortRank INT,
  ranking_isTied BOOLEAN,

  searchData_actAvg_rawValue DECIMAL(4,1),
  searchData_percentReceivingAid_rawValue DECIMAL(5,2),
  searchData_acceptanceRate_rawValue DECIMAL(5,2),
  searchData_tuition_rawValue INT,
  searchData_hsGpaAvg_rawValue DECIMAL(3,2),
  searchData_engineeringRepScore_rawValue TEXT,
  searchData_parentRank_rawValue TEXT,
  searchData_enrollment_rawValue INT,
  searchData_businessRepScore_rawValue TEXT,
  searchData_satAvg_rawValue INT,
  searchData_costAfterAid_rawValue INT,
  searchData_testAvgs_displayValue_0_value VARCHAR(255),
  searchData_testAvgs_displayValue_1_value VARCHAR(255),

  PRIMARY KEY (institution_displayName)
);
"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM us_news;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "us_news", us_news, append = TRUE, row.names = FALSE)
  message("Data loaded into us_news table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM us_news;")
print(result)
```

