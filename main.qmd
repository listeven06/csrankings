---
title: "Main"
format: html
editor: visual
---

## Libraries

```{r libraries}
install.packages(c("DBI", "RSQLite", "dbplyr", "tidyr", "dplyr", "readr", "knitr"))

library(RSQLite)
library(tidyr)
library(readr)
library(dplyr)
library(knitr)
library(DBI)


```

## Load Data

```{r load_datasets}

csrankings <- read_csv("datasets/csrankings.csv")
author_info <- read_csv("datasets/generated-author-info.csv")
acm_fellows <- read_csv("datasets/acm-fellows.csv")
turing_awards <- read.csv("datasets/turing.csv")
geolocation <- read.csv("datasets/geolocation.csv")
country_info <- read.csv("datasets/country-info.csv")
dblp_aliases <- read.csv("datasets/dblp-aliases.csv")
conference_ranking <- read.csv("datasets/conference_ranking.csv")
us_news <- read.csv("datasets/data.csv")
field_conference <- read.csv("datasets/field_conference.csv")

head(csrankings)
head(author_info)
head(acm_fellows)
head(turing_awards)
head(geolocation)
head(country_info)
head(dblp_aliases)
head(conference_ranking)
head(us_news)
head(field_conference)
```

## CS Ranking

### Split Names

```{r split_name}
names(csrankings)[names(csrankings) == "name"] <- "researcher_name"

# The regex explained:
#   ^([^\\s]+)       -> Matches the first token (first name) at the start.
#   \\s+             -> One or more spaces.
#   (?:(.*)\\s+)?    -> Optionally matches the middle part (middle name(s)) followed by space.
#   ([^\\s]+)$       -> Matches the last token (last name) at the end.
csrankings <- csrankings %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )

print(csrankings)

```

### Create and Load Data

```{r csrankings}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# csranking

drop_check <- "DROP TABLE IF EXISTS csrankings;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS csrankings (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    affiliation VARCHAR(255),
    homepage VARCHAR(2048),
    scholarid VARCHAR(16),
    PRIMARY KEY (researcher_name)
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM csrankings;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "csrankings", csrankings, append = TRUE, row.names = FALSE)
  message("Data loaded into csrankings table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(result)



RSQLite::dbDisconnect(connection)
```

## Country

### Create and Load Data

```{r country}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# country_info

drop_check <- "DROP TABLE IF EXISTS country_info;"

RSQLite::dbExecute(connection, drop_check)

query <- "
CREATE TABLE IF NOT EXISTS country_info (
    institution VARCHAR(255),
    region VARCHAR(255),
    countryabbrv VARCHAR(16),
    PRIMARY KEY (institution),
    FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);
"
RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM country_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "country_info", country_info, append = TRUE, row.names = FALSE)
  message("Data loaded into country_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM country_info;")
print(result)

RSQLite::dbExecute(connection, query)

```

## Geolocation

### Create and Load Data

```{r geolocation}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# geolocation

drop_check <- "DROP TABLE IF EXISTS geolocation;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS  geolocation (
    institution VARCHAR(255),
    latitude DOUBLE,
    longitude DOUBLE,
    PRIMARY KEY (institution),
    FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM geolocation;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "geolocation", geolocation, append = TRUE, row.names = FALSE)
  message("Data loaded into geolocation table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM geolocation;")
print(result)

RSQLite::dbExecute(connection, query)

```

## ACM Fellows

### Create and Load Data

```{r acm_fellows}
names(acm_fellows)[names(acm_fellows) == "year"] <- "award_year"
names(acm_fellows)[names(acm_fellows) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# asm_fellows

drop_check <- "DROP TABLE IF EXISTS acm_fellows;"

RSQLite::dbExecute(connection, drop_check)

query <- "
CREATE TABLE IF NOT EXISTS acm_fellows (
    researcher_name VARCHAR(255),
    award_year INT,
    PRIMARY KEY (researcher_name, award_year),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM acm_fellows;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "acm_fellows", acm_fellows, append = TRUE, row.names = FALSE)
  message("Data loaded into acm_fellows table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM acm_fellows;")
print(result)

RSQLite::dbExecute(connection, query)

```

## Generated Author Info

### Split Names

```{r generated_author}

names(author_info)[names(author_info) == "name"] <- "researcher_name"
names(author_info)[names(author_info) == "year"] <- "publication_year"

# The regex explained:
#   ^([^\\s]+)       -> Matches the first token (first name) at the start.
#   \\s+             -> One or more spaces.
#   (?:(.*)\\s+)?    -> Optionally matches the middle part (middle name(s)) followed by space.
#   ([^\\s]+)$       -> Matches the last token (last name) at the end.
author_info <- author_info %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )
```

### Create and Load Data

```{r create and load table}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# author_info

drop_check <- "DROP TABLE IF EXISTS generated_author_info;"

RSQLite::dbExecute(connection, drop_check)

# author_info
query <- "
    CREATE TABLE IF NOT EXISTS generated_author_info (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    dept VARCHAR(255),
    area VARCHAR(16),
    count INT,
    adjustedcount DOUBLE,
    publication_year INT,
    PRIMARY KEY (researcher_name, dept, area, publication_year),
    FOREIGN KEY (researcher_name) REFERENCES csranking(researcher_name) ON DELETE CASCADE,
    FOREIGN KEY (dept) REFERENCES csranking(affiliation) ON DELETE SET NULL
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM generated_author_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "generated_author_info", author_info, append = TRUE, row.names = FALSE)
  message("Data loaded into generated_author_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM generated_author_info;")
print(result)

RSQLite::dbDisconnect(connection)

```

## DBLP Aliases

### Create and Load Data

```{r dblp aliases}
names(dblp_aliases)[names(dblp_aliases) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# dblp aliases

drop_check <- "DROP TABLE IF EXISTS dblp_aliases;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS dblp_aliases (
    alias VARCHAR(255),
    researcher_name VARCHAR(255),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM dblp_aliases;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "dblp_aliases", dblp_aliases, append = TRUE, row.names = FALSE)
  message("Data loaded into dblp_aliases table.")
} else {
  message("Table already contains data. Skipping data load.")
}

dupes <- dbGetQuery(connection, "SELECT researcher_name, alias, count(*) as COUNT FROM dblp_aliases GROUP BY researcher_name, alias HAVING COUNT > 1;")
print(dupes)

RSQLite::dbDisconnect(connection)

```

## Turing

### Create and Load Data

```{r turing}

names(turing_awards)[names(turing_awards) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# turing awards

drop_check <- "DROP TABLE IF EXISTS turing;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS turing (
    researcher_name VARCHAR(255),
    year INT,
    PRIMARY KEY (researcher_name, year)
    FOREIGN KEY (researcher_name) REFERENCES csranking(researcher_name) ON DELETE CASCADE
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM turing;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "turing", turing_awards, append = TRUE, row.names = FALSE)
  message("Data loaded into turing table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM turing;")
print(result)

RSQLite::dbDisconnect(connection)

```

## Conference Field

### Create and Load Data

```{r conference_field}
# head(field_conference)


names(field_conference)[names(field_conference) == "field"] <- "specialized_field"
names(field_conference)[names(field_conference) == "conference"] <- "conference_name"

connection <- dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS field_conference;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS field_conference (
    major VARCHAR(255),
    specialized_field VARCHAR(255),
    conference_name VARCHAR(255),
    PRIMARY KEY (specialized_field, conference_name)
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM field_conference;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "field_conference", field_conference, append = TRUE, row.names = FALSE)
  message("Data loaded into field_conference table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM field_conference;")
print(result)

RSQLite::dbDisconnect(connection)
```

### conference_ranking

For the conference ranking (conference_ranking.csv) file, when you create a corresponding table, in addition to the three attributes for abbreviation, full name, rating, also include another attribute for “academic society” whose value can be ‘ACM’, ‘IEEE’, ‘ACM+IEEE’, or ‘other’. You will need to scrape this information from the conference full name. E.g., if a conference is titled “ACM conference on Machine Learning” since ACM appears in the title, we will the value ‘ACM’ for the “academic society”. Likewise, a conference such as “IEEE conference on Big Data” will be marked as an ‘IEEE’ conference. If neither IEEE nor ACM appear, then we will assign the value of ‘other’ to the field, while if both IEEE and ACM appear, we will assign the value ‘ACM+IEEE’.

```{r preprocess_conference_ranking}
colnames(conference_ranking)

names(conference_ranking)[names(conference_ranking) == "Antonym"] <- "acronym"
names(conference_ranking)[names(conference_ranking) == "Name"] <- "conference_name"
names(conference_ranking)[names(conference_ranking) == "Rank"] <- "rank"

colnames(conference_ranking)
head(conference_ranking)
```

```{r conference_ranking}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")


drop_check <- "DROP TABLE IF EXISTS conference_ranking;"

RSQLite::dbExecute(connection, drop_check)

# conference_ranking
query <- "
CREATE TABLE IF NOT EXISTS conference_ranking (
  acronym VARCHAR(16),
  conference_name VARCHAR(255),
  rank VARCHAR(2),
  academic_society VARCHAR(8),
  PRIMARY KEY (acronym, conference_name),
  FOREIGN KEY (acronym) REFERENCES generated_author_info(acronym)
);
"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM conference_ranking;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "conference_ranking", conference_ranking, append = TRUE, row.names = FALSE)
  message("Data loaded into conference_ranking table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM conference_ranking;")
print(result)

# Scrape academic_society column

query <- "
UPDATE conference_ranking
SET academic_society = CASE
    WHEN (conference_name LIKE '%ACM%' AND conference_name LIKE '%IEEE%') THEN 'ACM+IEEE'
    WHEN conference_name LIKE 'ACM%' THEN 'ACM'
    WHEN conference_name LIKE 'IEEE%' THEN 'IEEE'
    ELSE 'other'
END;
"

RSQLite::dbExecute(connection, query)

result <- dbGetQuery(connection, "SELECT * FROM conference_ranking;")
print(result)

RSQLite::dbDisconnect(connection)
```

```{r eda_conference_ranking}
result %>%
  group_by(acronym) %>% 
  summarize(
    n = n()
  ) %>% 
  arrange(desc(n))
```

### us_news

```{r preprocess_us_news}
colnames(us_news)

# Replace dots with underscores in column names
colnames(us_news) <- gsub("\\.", "_", colnames(us_news))

colnames(us_news)
```

```{r us_news}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS us_news;"

RSQLite::dbExecute(connection, drop_check)

# usnews / data
query <- "
CREATE TABLE IF NOT EXISTS us_news (
  institution_displayName VARCHAR(255),
  institution_schoolType VARCHAR(255),
  institution_aliasNames TEXT,
  institution_state VARCHAR(50),
  institution_city VARCHAR(255),
  institution_zip VARCHAR(10),
  institution_region VARCHAR(50),
  institution_isPublic BOOLEAN,
  institution_institutionalControl VARCHAR(255),
  institution_primaryPhotoCardThumb TEXT,

  ranking_displayRank VARCHAR(50),
  ranking_sortRank INT,
  ranking_isTied BOOLEAN,

  searchData_actAvg_rawValue DECIMAL(4,1),
  searchData_percentReceivingAid_rawValue DECIMAL(5,2),
  searchData_acceptanceRate_rawValue DECIMAL(5,2),
  searchData_tuition_rawValue INT,
  searchData_hsGpaAvg_rawValue DECIMAL(3,2),
  searchData_engineeringRepScore_rawValue TEXT,
  searchData_parentRank_rawValue TEXT,
  searchData_enrollment_rawValue INT,
  searchData_businessRepScore_rawValue TEXT,
  searchData_satAvg_rawValue INT,
  searchData_costAfterAid_rawValue INT,
  searchData_testAvgs_displayValue_0_value VARCHAR(255),
  searchData_testAvgs_displayValue_1_value VARCHAR(255),

  PRIMARY KEY (institution_displayName)
);
"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM us_news;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "us_news", us_news, append = TRUE, row.names = FALSE)
  message("Data loaded into us_news table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM us_news;")
print(result)
```

# Task 2 Results:

```{r}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

tables <- dbListTables(connection)

for (table in tables) {
  cat ("\n--- Dataset:", table, "---\n")
  data <- dbGetQuery(connection, paste("SELECT * FROM", table, "LIMIT 5"))
  print(data)
}

RSQLite::dbDisconnect(connection)
```

# Task 3.1

```{r missing_names}
connection <- dbConnect(SQLite(), "csrankings.db")

cs_names <- dbGetQuery(connection, "SELECT researcher_name FROM csrankings;")
gai_names <- dbGetQuery(connection, "SELECT researcher_name FROM generated_author_info;")
acm_names <- dbGetQuery(connection, "SELECT researcher_name FROM acm_fellows;")
turing_names <- dbGetQuery(connection, "SELECT researcher_name FROM turing;")

gai_query <- "
SELECT researcher_name
FROM generated_author_info
EXCEPT 
SELECT researcher_name
FROM csrankings;
"

gai_missing_in_cs <- dbGetQuery(connection, gai_query)


acm_query <- "
SELECT researcher_name
FROM acm_fellows
EXCEPT 
SELECT researcher_name
FROM csrankings;
"

acm_missing_in_cs <- dbGetQuery(connection, acm_query)

turing_query <- "
SELECT researcher_name
FROM turing
EXCEPT 
SELECT researcher_name
FROM csrankings;
"

turing_missing_in_cs <- dbGetQuery(connection, turing_query)

print(head(gai_missing_in_cs, 10)) # generated_author_info
print(head(acm_missing_in_cs, 10)) # acm
print(head(turing_missing_in_cs, 10)) # turing

dbDisconnect(connection)
```

### Generated Author Info

There were 67 missing names that were in generated_author_info but not in cs_ranking.

### ACM Fellows

There are 735 missing names that were in acm_fellows but not in cs_ranking.

### Turing

There are 62 missing names that were in turing_awards but not in cs_ranking.

```{r insert_missing_acm_into_csranking}

acm_missing_in_cs <- acm_missing_in_cs %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )

insert_query <- "
    INSERT INTO csrankings (researcher_name, first_name, middle_name, last_name, affiliation, homepage, scholarid)
    VALUES (?, ?, ?, ?, NULL, NULL, NULL);
"


connection <- dbConnect(SQLite(),"csrankings.db")

for(i in seq_len(nrow(acm_missing_in_cs))) {
  dbExecute(connection, insert_query, params = list(
    acm_missing_in_cs$researcher_name[i],
    acm_missing_in_cs$first_name[i],
    acm_missing_in_cs$middle_name[i],
    acm_missing_in_cs$last_name[i]
  ))
}

test <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(test)

dbDisconnect(connection)
```

```{r insert_missing_turing_into_cs_ranking}

# find the unique names only present in turing
turing_not_in_acm <- setdiff(turing_missing_in_cs$researcher_name, acm_missing_in_cs$researcher_name)

# print(turing_not_in_acm) 35 unique


# filter the df to only include the unique names.
missing_turing_filtered <- turing_missing_in_cs %>%
  filter(researcher_name %in% turing_not_in_acm)


missing_turing_filtered <- missing_turing_filtered %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )


insert_query <- "
    INSERT INTO csrankings (researcher_name, first_name, middle_name, last_name, affiliation, homepage, scholarid)
    VALUES (?, ?, ?, ?, NULL, NULL, NULL);
"

connection <- dbConnect(SQLite(),"csrankings.db")

for(i in seq_len(nrow(missing_turing_filtered))) {
  dbExecute(connection, insert_query, params = list(
    missing_turing_filtered$researcher_name[i],
    missing_turing_filtered$first_name[i],
    missing_turing_filtered$middle_name[i],
    missing_turing_filtered$last_name[i]
  ))
}

test <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(test)

dbDisconnect(connection)
```

```{r inserting_missing_gia_into_cs_ranking}
unique_gai_names <- setdiff(gai_missing_in_cs$researcher_name, union(acm_missing_in_cs$researcher_name, turing_missing_in_cs$researcher_name))

missing_gia_filtered <- gai_missing_in_cs %>%
  filter(researcher_name %in% unique_gai_names)

missing_gia_filtered <- missing_gia_filtered %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )

insert_query <- "
    INSERT INTO csrankings (researcher_name, first_name, middle_name, last_name, affiliation, homepage, scholarid)
    VALUES (?, ?, ?, ?, NULL, NULL, NULL);
"


connection <- dbConnect(SQLite(),"csrankings.db")

for(i in seq_len(nrow(missing_gia_filtered))) {
  dbExecute(connection, insert_query, params = list(
    missing_gia_filtered$researcher_name[i],
    missing_gia_filtered$first_name[i],
    missing_gia_filtered$middle_name[i],
    missing_gia_filtered$last_name[i]
  ))
}

test <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(test)

dbDisconnect(connection)



```

# Task 3.2

```{r testing_strategy}


connection <- dbConnect(SQLite(),"csrankings.db")

query <- "
    SELECT researcher_name, COUNT(*) AS COUNT FROM csrankings
    GROUP BY scholarid
    HAVING COUNT > 1;
"

test <- dbGetQuery(connection, query)
print(test)

dbDisconnect(connection)

```

## Rationale

We implemented a very simple duplicate detection method, relying on matching four key attributes: first name, last name, scholarid, and affiliation. The idea is that if there are two or more records having the same value for these fields, they very likely refer to the same individual. The list of authors' names, with their scholarid and affiliation listed, for example, "Michael Carey" - "12345" - "XYZ University" - and other records showing the same "Michael Carey" with the exact scholarid and affiliation, get marked as a duplicate. For the identified sets of probable duplicates, we used this method to resolve them: keep just one record of each and removes the additional rows from the table csranking. This methodology cleans the dataset, providing one record per researcher with no duplication. Though it is a very simple approach, it would work if the data is very organized and if the four chosen attributes are being consistently captured. This will provide a strict and straightforward rule for duplicate detection.

## Cleaning Names

```{r preprocess_fix_names}

connection <- dbConnect(SQLite(), "csrankings.db")

arvind_query <- "
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Arvind';
"

badri_query <- "
UPDATE csrankings
SET first_name = 'Badri', middle_name = 'N.', last_name = 'Vellambi', researcher_name = 'Badri N. Vellambi'
WHERE homepage = 'https://researchdirectory.uc.edu/p/vellambn';
"

bharti_query <- "
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Bharti';
"

biswa_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Biswa';
"

luqi_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Luqi';
"

mausam_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Mausam';
"

ronald_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Poppe:Ronald';
"

ramyaa_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Ramyaa';
"

robby_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Robby';
"

siddharth_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Siddharth';
"

jiaxiang_query <- "
UPDATE csrankings
SET first_name = 'Jiaxing', middle_name = 'Liu', last_name = '0001', researcher_name = 'Jiaxing Liu 001'
WHERE homepage = 'https://csse.szu.edu.cn/pages/user/index?id=1031';
"

emmert_query <-"
UPDATE csrankings
SET first_name = 'John', middle_name = 'Marty', last_name = 'Emmert', researcher_name = 'John Marty Emmert'
WHERE homepage = 'https://researchdirectory.uc.edu/p/emmertj';
"

kosters_query <-"
UPDATE csrankings
SET first_name = 'Walter', middle_name = 'A.', last_name = 'Kosters', researcher_name = 'Walter A. Kosters'
WHERE homepage = 'https://www.universiteitleiden.nl/en/staffmembers/walter-kosters#tab-2';
"

hawkins_query <-"
UPDATE csrankings
SET first_name = 'William', middle_name = NULL, last_name = 'Hawkins', researcher_name = 'William Hawkins'
WHERE homepage = 'https://researchdirectory.uc.edu/p/hawkinwh';
"


dbExecute(connection, arvind_query)
dbExecute(connection, badri_query)
dbExecute(connection, bharti_query)
dbExecute(connection, biswa_query)
dbExecute(connection, luqi_query)
dbExecute(connection, mausam_query)
dbExecute(connection, ronald_query)
dbExecute(connection, ramyaa_query)
dbExecute(connection, robby_query)
dbExecute(connection, siddharth_query)
dbExecute(connection, jiaxiang_query)
dbExecute(connection, emmert_query)
dbExecute(connection, kosters_query)
dbExecute(connection, hawkins_query)

```

## Implementation

824 people who have no scholarid because we inserted them in from acm_fellows

5342 people who have scholarid = 'NOSCHOLARPAGE'.

```{r implementing}

connection <- dbConnect(SQLite(), "csrankings.db")

test <- "
    SELECT researcher_name, scholarid, COUNT(*) as count
    FROM csrankings
    GROUP BY scholarid
    HAVING count > 5;
"

example <-"
SELECT *
FROM csrankings
WHERE scholarid = '4yki88YAAAAJ'
"

null_values <-"
SELECT * 
FROM csrankings
WHERE scholarid is NULL;
"

test_results <- dbGetQuery(connection, test)
example_results <- dbGetQuery(connection, example)
null_results <- dbGetQuery(connection, null_values)
print(test_results)
print(example_results)
print(null_results)
```

## Task 3.3 & 3.4

Determine if rows represent the same individual, then create a new table cs_ranking_clean where those individuals are merged onto a single row.

Group by (first initial, last name) 1) create first_initial column 2) group_by 3) summarize function, get max string length

```{r merge_duplicate_individuals}
library(RSQLite)
library(DBI)
library(dplyr)
library(stringr)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

csranking <- dbGetQuery(connection, "SELECT * FROM csrankings;")

# Step 0. Clean scholarid field
csranking_clean <- csranking %>%
  mutate(scholarid = ifelse(scholarid == "NOSCHOLARPAGE", NA, scholarid))

# Step 1. Split the data into two groups
group_with_id <- csranking_clean %>% filter(!is.na(scholarid)) #25048
group_without_id <- csranking_clean %>% filter(is.na(scholarid)) #6166

# Step 2. Process group with scholarid
duplicate_with_id <- group_with_id %>%
  # Calculate the information score for each record.
  mutate(info = nchar(first_name) +
           if_else(is.na(middle_name), 0L, nchar(middle_name)) +
           if_else(is.na(last_name), 0L, nchar(last_name))) %>%
  # Group by scholarid
  group_by(scholarid) %>%
  # Sort descending by info score so that the record with the most information comes first
  arrange(desc(info)) %>%
  # Summarise by taking the first (best) record as the canonical name and 
  # combining the other names (if any) as synonyms.
  summarise(
    author = first(researcher_name),
    synonym = paste(setdiff(researcher_name, first(researcher_name)), collapse = ", "),
    count = n()
  ) %>%
  ungroup() %>%
  # Only keep groups where more than one record was found (i.e. duplicates)
  filter(count > 1) %>%
  select(-count)


duplicate_without_id <- group_without_id %>%
  # Create a simple duplicate key.
  # If a last name exists, use the lower-case first letter of first_name plus the cleaned last_name.
  # Otherwise, fall back to cleaning the full researcher_name.
  mutate(
    norm_name_key = if_else(!is.na(last_name) & last_name != "",
                            paste0(tolower(substr(first_name, 1, 1)),
                                   tolower(gsub("[[:punct:][:digit:]]", "", last_name))),
                            tolower(gsub("[[:punct:][:digit:]]", "", middle_name))),
    # Compute an "information score": total length of first, middle, and last names.
    info = nchar(first_name) +
           if_else(is.na(middle_name), 0L, nchar(middle_name)) +
           if_else(is.na(last_name), 0L, nchar(last_name))
  ) %>%
  # Group by the duplicate key
  group_by(norm_name_key) %>%
  arrange(desc(info)) %>%  # the record with the most info comes first
  summarise(
    author = first(researcher_name),
    synonym = paste(setdiff(researcher_name, first(researcher_name)), collapse = ", "),
    count = n()
  ) %>%
  ungroup() %>%
  # Only keep groups where duplicates were detected (more than one record)
  filter(count > 1) %>%
  select(-count)

# Step 4. Combine the duplicate groups from both sets
duplicate_authors <- bind_rows(duplicate_with_id, duplicate_without_id)

print(duplicate_authors)

```
