---
title: "Main"
format: html
editor: visual
---

## Libraries

```{r libraries}
install.packages("tidyr")
install.packages("dplyr")
install.packages("DBI")
install.packages("readr")
install.packages("RSQLites")
library(tidyr)
library(readr)
library(dplyr)
library(DBI)
library(RSQLite)

```

## Load Data

```{r load_datasets}

csrankings <- read_csv("datasets/csrankings.csv")
author_info <- read_csv("datasets/generated-author-info.csv")
acm_fellows <- read_csv("datasets/acm-fellows.csv")
turing_awards <- read.csv("datasets/turing.csv")
geolocation <- read.csv("datasets/geolocation.csv")
country_info <- read.csv("datasets/country-info.csv")
dblp_aliases <- read.csv("datasets/dblp-aliases.csv")
conference_ranking <- read.csv("datasets/conference_ranking.csv")
us_news <- read.csv("datasets/data.csv")
field_conference <- read.csv("datasets/field_conference.csv")

```

## CS Ranking

### Split Names

```{r split_name}
names(csrankings)[names(csrankings) == "name"] <- "researcher_name"

# The regex explained:
#   ^([^\\s]+)       -> Matches the first token (first name) at the start.
#   \\s+             -> One or more spaces.
#   (?:(.*)\\s+)?    -> Optionally matches the middle part (middle name(s)) followed by space.
#   ([^\\s]+)$       -> Matches the last token (last name) at the end.
csrankings <- csrankings %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^([A-Za-zÀ-ÿ'\\-]+\\.?)(\\s+\\(?[A-Za-zÀ-ÿ'\\-\\s]+\\)?\\.?)*\\s+([A-Za-zÀ-ÿ'\\-]+(?:\\s+\\d{1,4})*)$",
    remove = FALSE 
  )

```

### Create and Load Data

```{r csrankings}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# csranking

drop_check <- "DROP TABLE IF EXISTS csrankings;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS csrankings (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    affiliation VARCHAR(255),
    homepage VARCHAR(2048),
    scholarid VARCHAR(16),
    PRIMARY KEY (researcher_name, affiliation)
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM csrankings;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "csrankings", csrankings, append = TRUE, row.names = FALSE)
  message("Data loaded into csrankings table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(result)

RSQLite::dbDisconnect(connection)
```

## Country

### Create and Load Data

```{r country}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# country_info

drop_check <- "DROP TABLE IF EXISTS country_info;"

RSQLite::dbExecute(connection, drop_check)

query <- "
CREATE TABLE IF NOT EXISTS country_info (
    institution VARCHAR(255),
    region VARCHAR(255),
    countryabbrv VARCHAR(16),
    PRIMARY KEY (institution),
    FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);
"
RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM country_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "country_info", country_info, append = TRUE, row.names = FALSE)
  message("Data loaded into country_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM country_info;")
print(result)

RSQLite::dbExecute(connection, query)

```

## Generated Author Info

### Split Names

```{r generated_author}

names(author_info)[names(author_info) == "name"] <- "researcher_name"
names(author_info)[names(author_info) == "year"] <- "publication_year"

# The regex explained:
#   ^([^\\s]+)       -> Matches the first token (first name) at the start.
#   \\s+             -> One or more spaces.
#   (?:(.*)\\s+)?    -> Optionally matches the middle part (middle name(s)) followed by space.
#   ([^\\s]+)$       -> Matches the last token (last name) at the end.
author_info <- author_info %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^([A-Za-zÀ-ÿ'\\-]+\\.?)(\\s+\\(?[A-Za-zÀ-ÿ'\\-\\s]+\\)?\\.?)*\\s+([A-Za-zÀ-ÿ'\\-]+(?:\\s+\\d{1,4})*)$",
    remove = FALSE 
  )
```

### Create and Load Data

```{r create and load table}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# author_info

drop_check <- "DROP TABLE IF EXISTS generated_author_info;"

RSQLite::dbExecute(connection, drop_check)

# author_info
query <- "
    CREATE TABLE IF NOT EXISTS generated_author_info (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    dept VARCHAR(255),
    area VARCHAR(16),
    count INT,
    adjustedcount DOUBLE,
    publication_year INT,
    PRIMARY KEY (researcher_name, dept, area, publication_year),
    FOREIGN KEY (researcher_name) REFERENCES csranking(researcher_name) ON DELETE CASCADE,
    FOREIGN KEY (dept) REFERENCES csranking(affiliation) ON DELETE SET NULL
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM generated_author_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "generated_author_info", author_info, append = TRUE, row.names = FALSE)
  message("Data loaded into generated_author_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM generated_author_info;")
print(result)

RSQLite::dbDisconnect(connection)

```

## DBLP Aliases

### Create and Load Data

```{r dblp aliases}
names(dblp_aliases)[names(dblp_aliases) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# dblp aliases

drop_check <- "DROP TABLE IF EXISTS dblp_aliases;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS dblp_aliases (
    alias VARCHAR(255),
    researcher_name VARCHAR(255),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM dblp_aliases;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "dblp_aliases", dblp_aliases, append = TRUE, row.names = FALSE)
  message("Data loaded into dblp_aliases table.")
} else {
  message("Table already contains data. Skipping data load.")
}

dupes <- dbGetQuery(connection, "SELECT researcher_name, alias, count(*) as COUNT FROM dblp_aliases GROUP BY researcher_name, alias HAVING COUNT > 1;")
print(dupes)

RSQLite::dbDisconnect(connection)

```

## Turing

### Create and Load Data

```{r turing}

names(turing_awards)[names(turing_awards) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# turing awards

drop_check <- "DROP TABLE IF EXISTS turing;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS turing (
    researcher_name VARCHAR(255),
    year INT,
    PRIMARY KEY (researcher_name, year)
    FOREIGN KEY (researcher_name) REFERENCES csranking(researcher_name) ON DELETE CASCADE
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM turing;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "turing", turing_awards, append = TRUE, row.names = FALSE)
  message("Data loaded into turing table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM turing;")
print(result)

RSQLite::dbDisconnect(connection)

```

###  

## Create Database

```{r create_database}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# acm_fellows
query <- "
CREATE TABLE IF NOT EXISTS acm_fellows (
    researcher_name VARCHAR(255),
    award_year INT,
    PRIMARY KEY (researcher_name, award_year),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);"

RSQLite::dbExecute(connection, query)


# geolocation
query <- "
    CREATE TABLE IF NOT EXISTS  geolocation (
    institution VARCHAR(255),
    latitude DOUBLE,
    longitude DOUBLE,
    PRIMARY KEY (institution),
    FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);"

RSQLite::dbExecute(connection, query)


RSQLite::dbDisconnect(connection)
```

```{r}
connection <- dbConnect(SQLite(), "csrankings.db")


# conference_ranging
query <- "
CREATE TABLE IF NOT EXISTS conference_ranking (
  acronym VARCHAR(16),
  conference_name VARCHAR(255),
  rank VARCHAR(2),
  PRIMARY KEY (acronym, conference_name),
  FOREIGN KEY (acronym) REFERENCES generated_author_info(acronym)
)
"

RSQLite::dbExecute(connection, query)


# usnews / data
query <- "
CREATE TABLE IF NOT EXISTS data (
  institution_displayName VARCHAR(255),
  institution_schoolType VARCHAR(255),
  institution_aliasNames VARCHAR(255),
  institution_state VARCHAR(255),
  institution_city VARCHAR(255),
  institution_zip INT,
  institution_region VARCHAR(255),
  institution_isPublic BOOL,
  institution_institutionalControl VARCHAR(255),
  institution_primaryPhotoCardThumb TEXT,
  
  
  PRIMARY KEY (institution_displayName)

)
"


```
