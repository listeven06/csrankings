---
title: "Main"
format: html
editor: visual
---

## Libraries

```{r libraries}
install.packages(c("DBI", "RSQLite", "dbplyr", "tidyr", "dplyr", "readr", "knitr"))

library(RSQLite)
library(tidyr)
library(readr)
library(dplyr)
library(knitr)
library(DBI)


```

## Load Data

```{r load_datasets}

csrankings <- read_csv("datasets/csrankings.csv")
author_info <- read_csv("datasets/generated-author-info.csv")
acm_fellows <- read_csv("datasets/acm-fellows.csv")
turing_awards <- read.csv("datasets/turing.csv")
geolocation <- read.csv("datasets/geolocation.csv")
country_info <- read.csv("datasets/country-info.csv")
dblp_aliases <- read.csv("datasets/dblp-aliases.csv")
conference_ranking <- read.csv("datasets/conference_ranking.csv")
us_news <- read.csv("datasets/data.csv")
field_conference <- read.csv("datasets/field_conference.csv")

head(csrankings)
head(author_info)
head(acm_fellows)
head(turing_awards)
head(geolocation)
head(country_info)
head(dblp_aliases)
head(conference_ranking)
head(us_news)
head(field_conference)
```

# Task 2

## CS Ranking

### Split Names

```{r split_name}
names(csrankings)[names(csrankings) == "name"] <- "researcher_name"

# The regex explained:
#   ^([^\\s]+)       -> Matches the first token (first name) at the start.
#   \\s+             -> One or more spaces.
#   (?:(.*)\\s+)?    -> Optionally matches the middle part (middle name(s)) followed by space.
#   ([^\\s]+)$       -> Matches the last token (last name) at the end.
csrankings <- csrankings %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )

print(csrankings)

```

### Create and Load Data

```{r csrankings}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# csranking

drop_check <- "DROP TABLE IF EXISTS csrankings;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS csrankings (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    affiliation VARCHAR(255),
    homepage VARCHAR(2048),
    scholarid VARCHAR(16),
    PRIMARY KEY (researcher_name)
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM csrankings;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "csrankings", csrankings, append = TRUE, row.names = FALSE)
  message("Data loaded into csrankings table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(result)



RSQLite::dbDisconnect(connection)
```

## Country

### Create and Load Data

```{r country}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# country_info

drop_check <- "DROP TABLE IF EXISTS country_info;"

RSQLite::dbExecute(connection, drop_check)

query <- "
CREATE TABLE IF NOT EXISTS country_info (
    institution VARCHAR(255),
    region VARCHAR(255),
    countryabbrv VARCHAR(16),
    PRIMARY KEY (institution),
    FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);
"
RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM country_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "country_info", country_info, append = TRUE, row.names = FALSE)
  message("Data loaded into country_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM country_info;")
print(result)

RSQLite::dbExecute(connection, query)

```

## Geolocation

### Create and Load Data

```{r geolocation}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# geolocation

drop_check <- "DROP TABLE IF EXISTS geolocation;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS  geolocation (
    institution VARCHAR(255),
    latitude DOUBLE,
    longitude DOUBLE,
    PRIMARY KEY (institution),
    FOREIGN KEY (institution) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM geolocation;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "geolocation", geolocation, append = TRUE, row.names = FALSE)
  message("Data loaded into geolocation table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM geolocation;")
print(result)

RSQLite::dbExecute(connection, query)

```

## ACM Fellows

### Create and Load Data

```{r acm_fellows}
names(acm_fellows)[names(acm_fellows) == "year"] <- "award_year"
names(acm_fellows)[names(acm_fellows) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# asm_fellows

drop_check <- "DROP TABLE IF EXISTS acm_fellows;"

RSQLite::dbExecute(connection, drop_check)

query <- "
CREATE TABLE IF NOT EXISTS acm_fellows (
    researcher_name VARCHAR(255),
    award_year INT,
    PRIMARY KEY (researcher_name, award_year),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM acm_fellows;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "acm_fellows", acm_fellows, append = TRUE, row.names = FALSE)
  message("Data loaded into acm_fellows table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM acm_fellows;")
print(result)

RSQLite::dbExecute(connection, query)

```

## Generated Author Info

### Split Names

```{r generated_author}

names(author_info)[names(author_info) == "name"] <- "researcher_name"
names(author_info)[names(author_info) == "year"] <- "publication_year"

# The regex explained:
#   ^([^\\s]+)       -> Matches the first token (first name) at the start.
#   \\s+             -> One or more spaces.
#   (?:(.*)\\s+)?    -> Optionally matches the middle part (middle name(s)) followed by space.
#   ([^\\s]+)$       -> Matches the last token (last name) at the end.
author_info <- author_info %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )
```

### Create and Load Data

```{r create and load table}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# author_info

drop_check <- "DROP TABLE IF EXISTS generated_author_info;"

RSQLite::dbExecute(connection, drop_check)

# author_info
query <- "
    CREATE TABLE IF NOT EXISTS generated_author_info (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    dept VARCHAR(255),
    area VARCHAR(16),
    count INT,
    adjustedcount DOUBLE,
    publication_year INT,
    PRIMARY KEY (researcher_name, dept, area, publication_year),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE,
    FOREIGN KEY (dept) REFERENCES csrankings(affiliation) ON DELETE SET NULL
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM generated_author_info;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "generated_author_info", author_info, append = TRUE, row.names = FALSE)
  message("Data loaded into generated_author_info table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM generated_author_info;")
print(result)

RSQLite::dbDisconnect(connection)

```

## DBLP Aliases

### Create and Load Data

```{r dblp aliases}
names(dblp_aliases)[names(dblp_aliases) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# dblp aliases

drop_check <- "DROP TABLE IF EXISTS dblp_aliases;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS dblp_aliases (
    alias VARCHAR(255),
    researcher_name VARCHAR(255),
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM dblp_aliases;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "dblp_aliases", dblp_aliases, append = TRUE, row.names = FALSE)
  message("Data loaded into dblp_aliases table.")
} else {
  message("Table already contains data. Skipping data load.")
}

dupes <- dbGetQuery(connection, "SELECT researcher_name, alias, count(*) as COUNT FROM dblp_aliases GROUP BY researcher_name, alias HAVING COUNT > 1;")
print(dupes)

RSQLite::dbDisconnect(connection)

```

## Turing

### Create and Load Data

```{r turing}

names(turing_awards)[names(turing_awards) == "name"] <- "researcher_name"

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")
# turing awards

drop_check <- "DROP TABLE IF EXISTS turing;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS turing (
    researcher_name VARCHAR(255),
    year INT,
    PRIMARY KEY (researcher_name, year)
    FOREIGN KEY (researcher_name) REFERENCES csrankings(researcher_name) ON DELETE CASCADE
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM turing;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "turing", turing_awards, append = TRUE, row.names = FALSE)
  message("Data loaded into turing table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM turing;")
print(result)

RSQLite::dbDisconnect(connection)

```

## Conference Field

### Create and Load Data

```{r conference_field}
# head(field_conference)


names(field_conference)[names(field_conference) == "field"] <- "specialized_field"
names(field_conference)[names(field_conference) == "conference"] <- "conference_name"

connection <- dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS field_conference;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS field_conference (
    major VARCHAR(255),
    specialized_field VARCHAR(255),
    conference_name VARCHAR(255),
    PRIMARY KEY (specialized_field, conference_name)
);
"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM field_conference;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "field_conference", field_conference, append = TRUE, row.names = FALSE)
  message("Data loaded into field_conference table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM field_conference;")
print(result)

RSQLite::dbDisconnect(connection)
```

### conference_ranking

For the conference ranking (conference_ranking.csv) file, when you create a corresponding table, in addition to the three attributes for abbreviation, full name, rating, also include another attribute for “academic society” whose value can be ‘ACM’, ‘IEEE’, ‘ACM+IEEE’, or ‘other’. You will need to scrape this information from the conference full name. E.g., if a conference is titled “ACM conference on Machine Learning” since ACM appears in the title, we will the value ‘ACM’ for the “academic society”. Likewise, a conference such as “IEEE conference on Big Data” will be marked as an ‘IEEE’ conference. If neither IEEE nor ACM appear, then we will assign the value of ‘other’ to the field, while if both IEEE and ACM appear, we will assign the value ‘ACM+IEEE’.

```{r preprocess_conference_ranking}
colnames(conference_ranking)

names(conference_ranking)[names(conference_ranking) == "Antonym"] <- "acronym"
names(conference_ranking)[names(conference_ranking) == "Name"] <- "conference_name"
names(conference_ranking)[names(conference_ranking) == "Rank"] <- "rank"

colnames(conference_ranking)
head(conference_ranking)
```

```{r conference_ranking}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")


drop_check <- "DROP TABLE IF EXISTS conference_ranking;"

RSQLite::dbExecute(connection, drop_check)

# conference_ranking
query <- "
CREATE TABLE IF NOT EXISTS conference_ranking (
  acronym VARCHAR(16),
  conference_name VARCHAR(255),
  rank VARCHAR(2),
  academic_society VARCHAR(8),
  PRIMARY KEY (acronym, conference_name),
  FOREIGN KEY (acronym) REFERENCES generated_author_info(acronym)
);
"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM conference_ranking;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "conference_ranking", conference_ranking, append = TRUE, row.names = FALSE)
  message("Data loaded into conference_ranking table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM conference_ranking;")
print(result)

# Scrape academic_society column

query <- "
UPDATE conference_ranking
SET academic_society = CASE
    WHEN (conference_name LIKE '%ACM%' AND conference_name LIKE '%IEEE%') THEN 'ACM+IEEE'
    WHEN conference_name LIKE 'ACM%' THEN 'ACM'
    WHEN conference_name LIKE 'IEEE%' THEN 'IEEE'
    ELSE 'other'
END;
"

RSQLite::dbExecute(connection, query)

result <- dbGetQuery(connection, "SELECT * FROM conference_ranking;")
print(result)

RSQLite::dbDisconnect(connection)
```

```{r eda_conference_ranking}
result %>%
  group_by(acronym) %>% 
  summarize(
    n = n()
  ) %>% 
  arrange(desc(n))
```

### us_news

```{r preprocess_us_news}
colnames(us_news)

# Replace dots with underscores in column names
colnames(us_news) <- gsub("\\.", "_", colnames(us_news))

colnames(us_news)
```

```{r us_news}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

drop_check <- "DROP TABLE IF EXISTS us_news;"

RSQLite::dbExecute(connection, drop_check)

# usnews / data
query <- "
CREATE TABLE IF NOT EXISTS us_news (
  institution_displayName VARCHAR(255),
  institution_schoolType VARCHAR(255),
  institution_aliasNames TEXT,
  institution_state VARCHAR(50),
  institution_city VARCHAR(255),
  institution_zip VARCHAR(10),
  institution_region VARCHAR(50),
  institution_isPublic BOOLEAN,
  institution_institutionalControl VARCHAR(255),
  institution_primaryPhotoCardThumb TEXT,

  ranking_displayRank VARCHAR(50),
  ranking_sortRank INT,
  ranking_isTied BOOLEAN,

  searchData_actAvg_rawValue DECIMAL(4,1),
  searchData_percentReceivingAid_rawValue DECIMAL(5,2),
  searchData_acceptanceRate_rawValue DECIMAL(5,2),
  searchData_tuition_rawValue INT,
  searchData_hsGpaAvg_rawValue DECIMAL(3,2),
  searchData_engineeringRepScore_rawValue TEXT,
  searchData_parentRank_rawValue TEXT,
  searchData_enrollment_rawValue INT,
  searchData_businessRepScore_rawValue TEXT,
  searchData_satAvg_rawValue INT,
  searchData_costAfterAid_rawValue INT,
  searchData_testAvgs_displayValue_0_value VARCHAR(255),
  searchData_testAvgs_displayValue_1_value VARCHAR(255),

  PRIMARY KEY (institution_displayName)
);
"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM us_news;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "us_news", us_news, append = TRUE, row.names = FALSE)
  message("Data loaded into us_news table.")
} else {
  message("Table already contains data. Skipping data load.")
}

result <- dbGetQuery(connection, "SELECT * FROM us_news;")
print(result)
```

# Task 2 Results:

```{r}
connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

tables <- dbListTables(connection)

for (table in tables) {
  cat ("\n--- Dataset:", table, "---\n")
  data <- dbGetQuery(connection, paste("SELECT * FROM", table, "LIMIT 5"))
  print(data)
}

RSQLite::dbDisconnect(connection)
```

# Task 3.1

```{r missing_names}
connection <- dbConnect(SQLite(), "csrankings.db")

cs_names <- dbGetQuery(connection, "SELECT researcher_name FROM csrankings;")
gai_names <- dbGetQuery(connection, "SELECT researcher_name FROM generated_author_info;")
acm_names <- dbGetQuery(connection, "SELECT researcher_name FROM acm_fellows;")
turing_names <- dbGetQuery(connection, "SELECT researcher_name FROM turing;")

gai_query <- "
SELECT researcher_name
FROM generated_author_info
EXCEPT 
SELECT researcher_name
FROM csrankings;
"

gai_missing_in_cs <- dbGetQuery(connection, gai_query)


acm_query <- "
SELECT researcher_name
FROM acm_fellows
EXCEPT 
SELECT researcher_name
FROM csrankings;
"

acm_missing_in_cs <- dbGetQuery(connection, acm_query)

turing_query <- "
SELECT researcher_name
FROM turing
EXCEPT 
SELECT researcher_name
FROM csrankings;
"

turing_missing_in_cs <- dbGetQuery(connection, turing_query)

print(head(gai_missing_in_cs, 10)) # generated_author_info
print(head(acm_missing_in_cs, 10)) # acm
print(head(turing_missing_in_cs, 10)) # turing

dbDisconnect(connection)
```

### Generated Author Info

There were 67 missing names that were in generated_author_info but not in cs_ranking.

### ACM Fellows

There are 735 missing names that were in acm_fellows but not in cs_ranking.

### Turing

There are 62 missing names that were in turing_awards but not in cs_ranking.

```{r insert_missing_acm_into_csranking}

acm_missing_in_cs <- acm_missing_in_cs %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )

insert_query <- "
    INSERT INTO csrankings (researcher_name, first_name, middle_name, last_name, affiliation, homepage, scholarid)
    VALUES (?, ?, ?, ?, NULL, NULL, NULL);
"


connection <- dbConnect(SQLite(),"csrankings.db")

for(i in seq_len(nrow(acm_missing_in_cs))) {
  dbExecute(connection, insert_query, params = list(
    acm_missing_in_cs$researcher_name[i],
    acm_missing_in_cs$first_name[i],
    acm_missing_in_cs$middle_name[i],
    acm_missing_in_cs$last_name[i]
  ))
}

test <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(test)

dbDisconnect(connection)
```

```{r insert_missing_turing_into_cs_ranking}

# find the unique names only present in turing
turing_not_in_acm <- setdiff(turing_missing_in_cs$researcher_name, acm_missing_in_cs$researcher_name)

# print(turing_not_in_acm) 35 unique


# filter the df to only include the unique names.
missing_turing_filtered <- turing_missing_in_cs %>%
  filter(researcher_name %in% turing_not_in_acm)


missing_turing_filtered <- missing_turing_filtered %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )


insert_query <- "
    INSERT INTO csrankings (researcher_name, first_name, middle_name, last_name, affiliation, homepage, scholarid)
    VALUES (?, ?, ?, ?, NULL, NULL, NULL);
"

connection <- dbConnect(SQLite(),"csrankings.db")

for(i in seq_len(nrow(missing_turing_filtered))) {
  dbExecute(connection, insert_query, params = list(
    missing_turing_filtered$researcher_name[i],
    missing_turing_filtered$first_name[i],
    missing_turing_filtered$middle_name[i],
    missing_turing_filtered$last_name[i]
  ))
}

test <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(test)

dbDisconnect(connection)
```

```{r inserting_missing_gia_into_cs_ranking}
unique_gai_names <- setdiff(gai_missing_in_cs$researcher_name, union(acm_missing_in_cs$researcher_name, turing_missing_in_cs$researcher_name))

missing_gia_filtered <- gai_missing_in_cs %>%
  filter(researcher_name %in% unique_gai_names)

missing_gia_filtered <- missing_gia_filtered %>%
  extract(
    col = researcher_name,
    into = c("first_name", "middle_name", "last_name"),
    regex = "^(\\S+)(?:\\s+(.*?))?\\s+(\\S+)$",
    remove = FALSE 
  )

insert_query <- "
    INSERT INTO csrankings (researcher_name, first_name, middle_name, last_name, affiliation, homepage, scholarid)
    VALUES (?, ?, ?, ?, NULL, NULL, NULL);
"


connection <- dbConnect(SQLite(),"csrankings.db")

for(i in seq_len(nrow(missing_gia_filtered))) {
  dbExecute(connection, insert_query, params = list(
    missing_gia_filtered$researcher_name[i],
    missing_gia_filtered$first_name[i],
    missing_gia_filtered$middle_name[i],
    missing_gia_filtered$last_name[i]
  ))
}

test <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(test)

dbDisconnect(connection)



```

# Task 3.2

```{r testing_strategy}


connection <- dbConnect(SQLite(),"csrankings.db")

query <- "
    SELECT researcher_name, COUNT(*) AS COUNT FROM csrankings
    GROUP BY scholarid
    HAVING COUNT > 1;
"

test <- dbGetQuery(connection, query)
print(test)

dbDisconnect(connection)

```

## Rationale

First we tried to implement a very simple duplicate detection method, relying on matching four key attributes: first name, last name, scholarid, and affiliation. The idea is that if there are two or more records having the same value for these fields, they very likely refer to the same individual. The list of authors' names, with their scholarid and affiliation listed, for example, "Michael Carey" - "12345" - "XYZ University" - and other records showing the same "Michael Carey" with the exact scholarid and affiliation, get marked as a duplicate. For the identified sets of probable duplicates, we used this method to resolve them: keep just one record of each and removes the additional rows from the table csranking. This methodology cleans the dataset, providing one record per researcher with no duplication. Though it is a very simple approach, it would work if the data is very organized and if the four chosen attributes are being consistently captured. However, there was a glaring problem: there were entries that had no scholarid. Either it was NULL value or 'NOSCHOLARPAGE'. This made it very difficult to detect duplicate authors given our initial simple approach.

We then used a method that first splitting the records into two groups: those with a scholar ID and those without. For the group with a scholar ID, any records sharing the same ID are treated as duplicates, and the one with the most complete name information is chosen as the main entry while the other variations are noted as duplicates. For the records without a scholar ID, a simple name-based key is created—by taking the first letter of the first name and a cleaned-up version of the last name—to group together similar names (for example, "Michael Carey," "M. Carey," and "Michael Carey001" all end up in the same group). Within each of these groups, the entry with the most detailed information is selected as the primary record, and the other names are recorded as duplicates.

The idea is that the record with the most detailed information is the one where the names are written out most completely. For instance, if one record shows "Michael Carey" and another shows "M. Carey" or "Michael Carey001," we assume that "Michael Carey" is more detailed because it spells out the name fully without abbreviations or extra numbers. We look at each part of the name—first, middle, and last—and judge detail by how much text is present; a longer version generally indicates that more information was provided. So, among duplicate entries, the one with the longest and most complete name fields is chosen as the primary record, while the shorter or less complete versions are recorded as duplicates.

## Cleaning Names

```{r preprocess_fix_names}

connection <- dbConnect(SQLite(), "csrankings.db")

arvind_query <- "
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Arvind';
"

badri_query <- "
UPDATE csrankings
SET first_name = 'Badri', middle_name = 'N.', last_name = 'Vellambi', researcher_name = 'Badri N. Vellambi'
WHERE homepage = 'https://researchdirectory.uc.edu/p/vellambn';
"

bharti_query <- "
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Bharti';
"

biswa_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Biswa';
"

luqi_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Luqi';
"

mausam_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Mausam';
"

ronald_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Poppe:Ronald';
"

ramyaa_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Ramyaa';
"

robby_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Robby';
"

siddharth_query <-"
UPDATE csrankings
SET first_name = researcher_name
WHERE researcher_name = 'Siddharth';
"

jiaxiang_query <- "
UPDATE csrankings
SET first_name = 'Jiaxing', middle_name = 'Liu', last_name = '0001', researcher_name = 'Jiaxing Liu 001'
WHERE homepage = 'https://csse.szu.edu.cn/pages/user/index?id=1031';
"

emmert_query <-"
UPDATE csrankings
SET first_name = 'John', middle_name = 'Marty', last_name = 'Emmert', researcher_name = 'John Marty Emmert'
WHERE homepage = 'https://researchdirectory.uc.edu/p/emmertj';
"

kosters_query <-"
UPDATE csrankings
SET first_name = 'Walter', middle_name = 'A.', last_name = 'Kosters', researcher_name = 'Walter A. Kosters'
WHERE homepage = 'https://www.universiteitleiden.nl/en/staffmembers/walter-kosters#tab-2';
"

hawkins_query <-"
UPDATE csrankings
SET first_name = 'William', middle_name = NULL, last_name = 'Hawkins', researcher_name = 'William Hawkins'
WHERE homepage = 'https://researchdirectory.uc.edu/p/hawkinwh';
"


dbExecute(connection, arvind_query)
dbExecute(connection, badri_query)
dbExecute(connection, bharti_query)
dbExecute(connection, biswa_query)
dbExecute(connection, luqi_query)
dbExecute(connection, mausam_query)
dbExecute(connection, ronald_query)
dbExecute(connection, ramyaa_query)
dbExecute(connection, robby_query)
dbExecute(connection, siddharth_query)
dbExecute(connection, jiaxiang_query)
dbExecute(connection, emmert_query)
dbExecute(connection, kosters_query)
dbExecute(connection, hawkins_query)

```

## Implementation

824 people who have no scholarid because we inserted them in from acm_fellows

5342 people who have scholarid = 'NOSCHOLARPAGE'.

```{r implementing}

connection <- dbConnect(SQLite(), "csrankings.db")

test <- "
    SELECT researcher_name, scholarid, COUNT(*) as count
    FROM csrankings
    GROUP BY scholarid
    HAVING count > 5;
"

example <-"
SELECT *
FROM csrankings
WHERE scholarid = '4yki88YAAAAJ'
"

null_values <-"
SELECT * 
FROM csrankings
WHERE scholarid is NULL;
"

test_results <- dbGetQuery(connection, test)
example_results <- dbGetQuery(connection, example)
null_results <- dbGetQuery(connection, null_values)
print(test_results)
print(example_results)
print(null_results)
```

## Task 3.3

Determine if rows represent the same individual, then create a new table cs_ranking_clean where those individuals are merged onto a single row.

Group by (first initial, last name) 1) create first_initial column 2) group_by 3) summarize function, get max string length

```{r duplicate_author}
library(RSQLite)
library(DBI)
library(dplyr)
library(stringr)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

csrankings <- dbGetQuery(connection, "SELECT * FROM csrankings;")

dbDisconnect(connection)

# Step 0. Clean scholarid field
csrankings_clean <- csrankings %>%
  mutate(scholarid = ifelse(scholarid == "NOSCHOLARPAGE", NA, scholarid))

# Step 1. Split the data into two groups
group_with_id <- csrankings_clean %>% filter(!is.na(scholarid)) #25048
group_without_id <- csrankings_clean %>% filter(is.na(scholarid)) #6166

# Step 2. Process group with scholarid
duplicate_with_id <- group_with_id %>%
  # Calculate the information score for each record.
  mutate(info = nchar(first_name) +
           if_else(is.na(middle_name), 0L, nchar(middle_name)) +
           if_else(is.na(last_name), 0L, nchar(last_name))) %>%
  # Group by scholarid
  group_by(scholarid) %>%
  # Sort descending by info score so that the record with the most information comes first
  arrange(desc(info)) %>%
  # Summarise by taking the first (best) record as the author name and 
  # combining the other names (if any) as synonyms.
  summarise(
    author = first(researcher_name),
    synonym = paste(setdiff(researcher_name, first(researcher_name)), collapse = ", "),
    count = n()
  ) %>%
  ungroup() %>%
  # Only keep groups where more than one record was found (i.e. duplicates)
  filter(count > 1) %>%
  select(-count)


duplicate_without_id <- group_without_id %>%
  # Create a simple duplicate key.
  # If a last name exists, use the lower-case first letter of first_name plus the cleaned last_name.
  # Otherwise, fall back to cleaning the full researcher_name.
  mutate(
    norm_name_key = if_else(!is.na(last_name) & last_name != "",
                            paste0(tolower(substr(first_name, 1, 1)),
                                   tolower(gsub("[[:punct:][:digit:]]", "", last_name))),
                            tolower(gsub("[[:punct:][:digit:]]", "", middle_name))),
    # Compute an "information score": total length of first, middle, and last names.
    info = nchar(first_name) +
           if_else(is.na(middle_name), 0L, nchar(middle_name)) +
           if_else(is.na(last_name), 0L, nchar(last_name))
  ) %>%
  # Group by the duplicate key
  group_by(norm_name_key) %>%
  arrange(desc(info)) %>%  # the record with the most info comes first
  summarise(
    author = first(researcher_name),
    synonym = paste(setdiff(researcher_name, first(researcher_name)), collapse = ", "),
    count = n()
  ) %>%
  ungroup() %>%
  # Only keep groups where duplicates were detected (more than one record)
  filter(count > 1) %>%
  select(-count)

# Step 4. Combine the duplicate groups from both sets
duplicate_authors <- bind_rows(duplicate_with_id, duplicate_without_id) #4782

print(duplicate_authors)

```

## Task 3.4

```{r clean_csrankings}

# Assume csrankings_clean already exists from earlier steps (with scholarid cleaned)
# (i.e. csrankings_clean was produced as:)
# csrankings_clean <- csrankings %>%
#   mutate(scholarid = ifelse(scholarid == "NOSCHOLARPAGE", NA, scholarid))

# -------------------------------------------------------------------
# 1. Define a helper function that merges a vector of strings by taking the longest.
merge_longest <- function(x) {
  # Remove duplicates and any NA values
  x <- unique(na.omit(x))
  if(length(x) == 0) return(NA_character_)
  if(length(x) == 1) return(x)
  # Otherwise, choose the string with the most characters (ties: the first maximum)
  x[which.max(nchar(x))]
}

# -------------------------------------------------------------------
# 2. Create a merge key for each record.
# For records with a scholarid, we use that;
# for records without a scholarid, we compute a normalized name key.
csrankings_keyed <- csrankings_clean %>%
  mutate(merge_key = if_else(!is.na(scholarid),
                             scholarid,
                             if_else(!is.na(last_name) & last_name != "",
                                     paste0(tolower(substr(first_name, 1, 1)),
                                            tolower(gsub("[[:punct:][:digit:]]", "", last_name))),
                                     # If no last name is available, use a cleaned version of the middle name
                                     tolower(gsub("[[:punct:][:digit:]]", "", middle_name)))
                             )
         )

# -------------------------------------------------------------------
# 3. Group by the merge key and merge (summarise) the attributes.
# For most attributes we use merge_longest().
# For researcher_name we also collect all distinct names so that we can record synonyms.
csrankings_clean <- csrankings_keyed %>%
  group_by(merge_key) %>%
  summarise(
    # For researcher_name we first collect all distinct non-NA names...
    researcher_name_all = list(unique(researcher_name[!is.na(researcher_name)])),
    # ...then choose the one with the most characters as the primary name.
    researcher_name = merge_longest(researcher_name),
    # Any other names (if present) become synonyms.
    synonym = {
      all_names <- unique(researcher_name[!is.na(researcher_name)])
      primary <- merge_longest(researcher_name)
      other_names <- setdiff(all_names, primary)
      if(length(other_names) == 0) NA_character_ else paste(other_names, collapse = ", ")
    },
    first_name   = merge_longest(first_name),
    middle_name  = merge_longest(middle_name),
    last_name    = merge_longest(last_name),
    affiliation  = merge_longest(affiliation),
    homepage     = merge_longest(homepage),
    scholarid    = merge_longest(scholarid)
  ) %>%
  ungroup() %>%
  # Optionally, drop the merge key and the temporary researcher_name_all list:
  select(-merge_key, -researcher_name_all, -synonym)

print(csrankings_clean)

```

## Task 3.5

```{r clean_generated_author_info}

synonym_map <- duplicate_authors %>%
  separate_rows(synonym, sep = ", ") %>%
  select(researcher_name = synonym, primary_author = author) %>%
  bind_rows(data.frame(researcher_name = duplicate_authors$author, 
                       primary_author = duplicate_authors$author)) %>%
  distinct()

generated_author_info_clean <- author_info %>%
  left_join(synonym_map, by = "researcher_name") %>%
  mutate(primary_author = coalesce(primary_author, researcher_name)) %>%
  
  # Step 2. Group by the primary author and publication year
  group_by(primary_author, publication_year) %>%
  
  # Step 3. Summarise by summing the counts and picking representative values for the other columns.
  summarise(
    count       = sum(count, na.rm = TRUE),
    first_name  = first(first_name),
    middle_name = first(middle_name),
    last_name   = first(last_name),
    dept        = first(dept),
    area        = first(area),
    .groups     = "drop"
  )

head(generated_author_info_clean,20)


```

```{r create_clean_SQL_tables}

connection = dbConnect(SQLite(), 'csrankings.db')

drop_check <- "DROP TABLE IF EXISTS csrankings_clean;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS csrankings_clean (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    affiliation VARCHAR(255),
    homepage VARCHAR(2048),
    scholarid VARCHAR(16),
    PRIMARY KEY (researcher_name)
);"

RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM csrankings_clean;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "csrankings_clean", csrankings_clean, append = TRUE, row.names = FALSE)
  message("Data loaded into csrankings_clean table.")
} else {
  message("Table already contains data. Skipping data load.")
}




names(generated_author_info_clean)[names(generated_author_info_clean) == "primary_author"] <- "researcher_name"

drop_check <- "DROP TABLE IF EXISTS generated_author_info_clean;"

RSQLite::dbExecute(connection, drop_check)

# author_info
query <- "
    CREATE TABLE IF NOT EXISTS generated_author_info_clean (
    researcher_name VARCHAR(255),
    first_name VARCHAR(225),
    middle_name VARCHAR(225),
    last_name VARCHAR(225),
    dept VARCHAR(255),
    area VARCHAR(16),
    count INT,
    publication_year INT,
    PRIMARY KEY (researcher_name, dept, area, publication_year),
    FOREIGN KEY (researcher_name) REFERENCES csranking(researcher_name) ON DELETE CASCADE,
    FOREIGN KEY (dept) REFERENCES csranking(affiliation) ON DELETE SET NULL
);"


RSQLite::dbExecute(connection, query)

row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM generated_author_info_clean;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "generated_author_info_clean", generated_author_info_clean, append = TRUE, row.names = FALSE)
  message("Data loaded into generated_author_info_clean table.")
} else {
  message("Table already contains data. Skipping data load.")
}

RSQLite::dbDisconnect(connection)

```

`generated_author_info_clean` table has unique (primary_author, publication_year). This means that there will not be multiple rows (entries) that are referring to the same person within that publication year showing up more than once. Ifthe same author shows up by 2 or more different names, we merged them and used the our `duplicate_authors` data frame to create a synonym map that helps map the primary_author to their respective other names. By doing so, our `generated_author_info_clean` would need to add the counts together of those who show up in multiple rows.`generated_author_info_clean` does not contain `adjustedCount` because we simply can't add them up. It's more complicated than that so we left it out. So in total, we have 8 columns: `researcher_name, first_name, middle_name, last_name, dept, area, count, and publication_year` .

# Task 4.1
