---
title: "data_cleaning"
format: html
---

## Task 1

Check if the names of the authors in generated_author_info, acm_fellows, and turing also appear in csrankings.csv table.

```{r load_tables}
library(readr)

csrankings <- read_csv("datasets/csrankings.csv")
author_info <- read_csv("datasets/generated-author-info.csv")
acm_fellows <- read_csv("datasets/acm-fellows.csv")
turing_awards <- read_csv("datasets/turing.csv")

head(csrankings)
head(author_info)
head(acm_fellows)
head(turing_awards)
```

```{r check_names}
library(dplyr)

# Check author_info names not in CS rankings
author_info %>% 
  distinct(name, .keep_all = TRUE) %>%
  select(name, dept) %>% 
  filter(!(name %in% csrankings$name)) %>% 
  rename(affiliation = dept)

# Check acm_fellows names not in CS rankings
acm_fellows %>% 
  distinct(name) %>% 
  filter(!(name %in% csrankings$name))

# Check turing_awards names not in CS rankings
turing_awards %>% 
  distinct(name) %>% 
  filter(!(name %in% csrankings$name))
```

Note:
author_info has csrankings$affiliation,
acm_fellows and turing_awards only have 'name'

Note 2:
potential duplicates when inserting names

Insert:
1) author_info (goes first since it has affiliation)
2) acm_fellows - author_info
3) turing_awards - acm_fellows - author_info

```{r insert_data}
library(RSQLite)
library(DBI)
library(dplyr)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

# Insert author_info
# Retrieve vector of names already in csrankings
csranking_names <- dbGetQuery(connection, "SELECT researcher_name FROM csrankings;")$researcher_name

author_info_toInsert <- author_info %>% 
  distinct(name, .keep_all = TRUE) %>%
  select(name, dept) %>% 
  filter(!(name %in% csranking_names)) %>% 
  rename(researcher_name = name,
      affiliation = dept)

dbWriteTable(connection, "csrankings", author_info_toInsert, append = TRUE, row.names = FALSE)


# Insert acm_fellows
csranking_names <- dbGetQuery(connection, "SELECT researcher_name FROM csrankings;")$researcher_name

acm_fellows_toInsert <- acm_fellows %>% 
  distinct(name) %>% 
  filter(!(name %in% csranking_names)) %>% 
  rename(researcher_name = name)

dbWriteTable(connection, "csrankings", acm_fellows_toInsert, append = TRUE, row.names = FALSE)


# Insert turing_awards
csranking_names <- dbGetQuery(connection, "SELECT researcher_name FROM csrankings;")$researcher_name

turing_awards_toInsert <- turing_awards %>% 
  distinct(name) %>% 
  filter(!(name %in% csranking_names)) %>% 
  rename(researcher_name = name)

dbWriteTable(connection, "csrankings", turing_awards_toInsert, append = TRUE, row.names = FALSE)


result <- dbGetQuery(connection, "SELECT * FROM csrankings;")
print(result)

RSQLite::dbDisconnect(connection)
```


## Task 3

Determine if rows represent the same individual, then create a new table cs_ranking_clean where those individuals are merged onto a single row.

Group by (first initial, last name)
1) create first_initial column
2) group_by
3) summarize function, get max string length

```{r merge_duplicate_individuals}
library(RSQLite)
library(DBI)
library(dplyr)
library(stringr)

connection <- RSQLite::dbConnect(SQLite(), "csrankings.db")

csrankings <- dbGetQuery(connection, "SELECT * FROM csrankings;")
head(csrankings)

csrankings <- csrankings %>%
  mutate(name = researcher_name) %>%
  separate(
    col = name,
    into = c("first_name", "middle_name", "last_name"),
    sep = " ", 
    extra = "merge",  # Ensures last_name gets only the last word
    fill = "right"    # Fills missing middle name with NA
  )

csrankings <- csrankings %>% 
  mutate(scholarid = if_else(scholarid == "NOSCHOLARPAGE", NA, scholarid))
head(csrankings)

csrankings_clean1 <- csrankings %>% 
  filter(!is.na(scholarid)) %>% 
  group_by(scholarid) %>% 
  summarize(
    researcher_name = researcher_name[which.max(nchar(researcher_name))],
    homepage = first(homepage),
    affiliation = first(affiliation)
  ) %>% 
  arrange(researcher_name)
head(csrankings_clean1)

csrankings_clean2 <- csrankings %>%
  filter(!(researcher_name %in% csrankings_clean$researcher_name)) %>% 
  group_by(last_name) %>% 
  summarize(
    first_name = first(na.omit(first_name)),   # Choose first non-NA first name
    middle_name = first(na.omit(middle_name)), # Choose first non-NA middle name
    last_name = first(last_name),              # Keep last name (since we grouped by it)
    across(everything(), first)                # Keep first occurrence of other columns
  ) %>%
  ungroup()
head(csrankings_clean2)

csrankings_clean <- bind_rows(csrankings_clean1, csrankings_clean2)
head(csrankings_clean)

csranking_names <- dbGetQuery(connection, "SELECT researcher_name FROM csrankings_clean;")$researcher_name

csrankings_clean <- csrankings_clean %>% 
  filter(!(researcher_name %in% csranking_names))
csrankings_clean

drop_check <- "DROP TABLE IF EXISTS csrankings_clean;"

RSQLite::dbExecute(connection, drop_check)

query <- "
    CREATE TABLE IF NOT EXISTS csrankings_clean (
    researcher_name VARCHAR(255),
    first_name VARCHAR(255),
    middle_name VARCHAR(255),
    last_name VARCHAR(255),
    affiliation VARCHAR(255),
    homepage VARCHAR(2048),
    scholarid VARCHAR(16),
    PRIMARY KEY (researcher_name)
);"

RSQLite::dbExecute(connection, query)


row_count <- dbGetQuery(connection, "SELECT COUNT(*) AS count FROM csrankings_clean;")
if (row_count$count == 0) {
  # Only load the data if the table is empty
  dbWriteTable(connection, "csrankings_clean", csrankings_clean, append = TRUE, row.names = FALSE)
  message("Data loaded into csrankings_clean table.")
} else {
  message("Table already contains data. Skipping data load.")
}

csrankings_clean <- dbGetQuery(connection, "SELECT * FROM csrankings_clean;")
print(csrankings_clean)

RSQLite::dbDisconnect(connection)
```


